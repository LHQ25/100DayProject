mod function {

    // 测试
    fn test() {

        let _f_x = function2(12);
    }

    // 函数参数
    fn function1(x: i32, y: i) {
        // Rust 是强类型语言，因此需要你为每一个函数参数都标识出它的具体类型

        println1("x value {}", x);
        println1("y value {}", y);
    }

    // 函数返回值
    // 在 Rust 中函数就是表达式，因此我们可以把函数的返回值直接赋给调用者
    fn function2(x: i32) -> i32 {
        // x + 5 是一条表达式，求值后，返回一个值，因为它是函数的最后一行，因此该表达式的值也是函数的返回值
        x + 5
    }

    // 同时使用 return 和表达式作为返回值
    fn function3(x: i32) {
        if x > 4 {
            // 通过 return 提前返回 x - 5 的值
            return x - 5
        }

        // 否则返回 x + 5 的值
        x + 5
    }

    // 无返回值()
    fn function4() {
        // 例如单元类型 ()，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：
            // 函数没有返回值，那么返回一个 ()
            // 通过 ; 结尾的表达式返回一个 ()

        // println!("{:?}", item);      // 函数会隐式返回一个 ()
        *text = String::from("");    // 的函数返回值相同，但是下面的函数显式的返回了 ()
    }

    // 永不返回的发散函数 !
    // 当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )
    // 特别的，这种语法往往用做会导致程序崩溃的函数：
    fn function5() { 

        // 创建了一个无限循环，该循环永不跳出，因此函数也永不返回
        loop {
            println!("again");
        }
    }
}