//
//  01异步函数动机.swift
//  Swift_Async
//
//  Created by 9527 on 2022/9/5.
//

import Foundation

/*
 异步函数，或者说支持 async 和 await 的函数，允许开发者使用和同步函数类似的语言结构，这立刻就解决了上面的几乎所有问题：
    1. 嵌套的回调可以被写为多个 async/await，不再有额外的队列派发所导致的缩进。
    2. 异步函数保有调用栈，因此可以使用 throws 和正常的返回值来分别表达错误路径和正常路径，调用者需要关心的结果被明确分为两类，且内层错误可以很容易地继续抛出到更外层，以便让合适的调用者进行处理。
    3. 使用 if 等语句时，行为模式和同步代码一致。这也为调试和测试代码提供了更易用和直观的工具。
    4. 异步函数必须有明确的退出路径：要么返回可用的值，要么抛出错误。编译器会保证异步函数结束时，调用者会且仅会收到一个结果，而不像原来忘记调用 completion 或者多次调用。
    5. 异步函数的函数签名和同步函数更加类似，框架开发者创建异步函数的阻力变小了。只要有异步操作的需求，将同步函数改写为异步函数的难度要远远小于把它改写为回调的难度。这也鼓励了框架和 API 的维护者提供异步函数版本。
    6. 开发者不再需要手动进行派发和关心线程调度。虽然在 await 后我们依然无法确定线程，但是可以使用 actor 类型来提供合理的隔离环境。异步函数和并发底层使用了全新的协作式线程池 (cooperative thread pool) 进行调度，这为异步代码提供更多的优化空间。
 */

//MARK: - 1. 线程放弃和暂停点
/*
 和同步函数最大的不同在于，异步函数可以放弃自己当前占有的线程。
 有一些关于异步函数的讨论，会把异步函数的运行理解为：编译器把异步函数切割成多个部分，每个部分拥有自己分离的存储空间，并可以由运行环境进行调度。
 我们可以把每个这种被切割后剩余的执行单元称作续体 (continuation)，
 而一个异步函数，在执行时，就是多个续体依次运行的结果。

 现在只需要将异步函数想象成和普通函数一样的东西，只不过它具有放弃线程进行暂停，并在稍后再从暂停点继续执行的特殊能力就可以了

 不论是同步函数还是异步函数，对它们的调用只是最简单的 apply 指令。
 异步函数虽然具有放弃线程的能力，但它自己本身并不会使用这个能力：
 它只会通过对另外的异步函数进行方法调用，或是通过主动创建续体，才能有机会暂停。
 这些被调用的方法和续体，有时会要求当前异步函数放弃线程并等待某些事情完成 (比如续体完结)。
 当完成后，本来的函数将会继续执行。

 await 充当的角色，就是标记出一个潜在的暂停点 (suspend point)。
 在异步函数中，可能发生暂停的地方，编译器会要求我们明确使用 await 将它标记出来。
 除此之外，await并没有其他更多的语义或是运行时的特性。
 当控制权回到异步函数中时，它会从之前停止的地方开始继续运行。但是“桃花依旧笑春风”的同时，“人面不知何处去”也会是一个事实：虽然部分状态，比如原来的输入参数等，在 await 前后会被保留，但是返回到当前异步函数时，它并不一定还运行在和之前同样的线程中，
 异步函数所在类型中的实例成员也可能发生了变化。await 是一个明确的标识，编译器强制我们写明 await 的意义，就是要警示开发者，await 两侧的代码会处在完全不同的世界中。

 但另一方面，await 仅仅只是一个潜在的暂停点，而非必然的暂停点,实际上会不会触发“暂停”，需要看被调用的函数的具体实现和运行时提供的执行器是否需要触发暂停。
 很多的异步函数并不仅仅是异步函数，它们可能是某个 actor 中的同步函数，但作为 actor 的一部分运行，在外界调用时表现为异步函数。
 Swift 会保证这样的函数能切换到它们自己的 actor 隔离域里完成执行
 */
